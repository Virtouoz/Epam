1. Дайте определение массиву. Как осуществляется индексация элементов массива. Как необходимо обращаться к i-му
элементу массива?
Answer:
        Массив представляет набор однотипных значений. new тип_данных[количество_элементов]. Обращение к элементу
       одномерного массива осуществляется через имя массива с указанием в квадратных скобках индекса элемента.
        Индексация элементов массива начинается с нуля! array[i]

2. Приведите способы объявления и инициализации одномерных и двумерных массивов примитивных и ссылочных
типов. Укажите разницу, между массивами примитивных и ссылочных типов.
Answer:
        int[] data;                 int[][] nums2;
        data = new int[]{3,8,1,7};  nums2 = {{0,1,2},{3,4,5}};
        data = new int[4]           nums2 = new int[2][3];
        Примитивные типы представляют собой одиночные значения. Ссылочные типы агрегируют типы, которые содержат
       нулевые или более примитивные значения или объекты.

3. Объясните, что значит клонирование массива, как в Java можно клонировать массив, в чем состоит разница в
клонировании массивов примитивных и ссылочных типов.
Answer:
        *.clone()
        Клонирование массива ссылочного типа приводит к тому что ссылки на объекты копируются. Что приводит к изменению
       объектов и в оригинале и в клоне. Однако в случае массива примитивов создаются новые объекты и изменение оригинала
       не затрагивает клон.

4. Объясните, что представляет собой двумерных массив в Java, что такое “рваный массив”. Как узнать количество
строк и количество элементов в каждой строке для “рваного” массива?
Answer:
        int[][] array = {{1,2,3},{4,5}};
        *.length - (количество строк)
        array[i].length

5. Объясните ситуации, когда в java-коде могут возникнуть следующие исключительные ситуации
java.lang.ArrayIndexOutOfBoundsException и java.lang.ArrayStoreException.
Answer:
        ArrayIndexOutOfBoundsException – это исключение, появляющееся во время выполнения. Оно возникает тогда,
       когда мы пытаемся обратиться к элементу массива по отрицательному или превышающему размер массива индексу.
        ArrayStoreException - если попытаться записать в ячейку массива ссылку на объект неправильного типа.

6. Объясните, зачем при кодировании разделять решаемую задачу на методы. Поясните, как вы понимаете выражение:
“Один метод не должен выполнять две задачи”.
Answer:
        Для нормализации задачи, упрощает чтение кода, упрощает и ускоряет написание кода, дает возможность
       работать в команде.
        “Один метод не должен выполнять две задачи” - усложняет работу, проще написать два метода и вызвать один в
       другом. Также могут возникнуть трудности с возвращаемыми данными, так как метод возвращает или что-то одно,
       или ничего.

7. Объясните, как в Java передаются параметры в методы, в чем особенность передачи в метод значения примитивного
типа, а в чем ссылочного.
Answer:
       - Передача по значению (by value). Значения фактических параметров копируются. Вызываемый метод создает свою
       копию значений аргументов и затем ее использует. Поскольку работа ведется с копией, на исходный параметр это
       никак не влияет.
       - Передача по ссылке (by reference). Параметры передаются как ссылка (адрес) на исходную переменную.
       Вызываемый метод не создает свою копию, а ссылается на исходное значение. Следовательно, изменения, сделанные
       в вызываемом методе, также будут отражены в исходном значении.
         Java всегда передает параметры по значению!

8. Объясните, как в метод передать массив. И как массив вернуть из метода. Можно ли в методе изменить размер
переданного массива.
Answer:
        public int[] f(int[] array)
        Невозможно изменить размер массива! Но вы можете скопировать элемент одного массива в другой массив,
       создав массив большего размера.

9. Поясните, что означает выражение ‘вернуть значение из метода’. Как можно вернуть значение из метода. Есть ли
разница при возврате значений примитивного и ссылочного типов.
Answer:
        public float func(...)
        float - тип возвращаемого значения.

10. Перечислите известные вам алгоритмы сортировки значений, приведите код, реализующий это алгоритмы.
Answer:
        - Сортировка выбором (Selection Sort)
        int[] array = {10, 2, 10, 3, 1, 2, 5};
        System.out.println(Arrays.toString(array));
        for (int left = 0; left < array.length; left++) {
        	int minInd = left;
        	for (int i = left; i < array.length; i++) {
        		if (array[i] < array[minInd]) {
        			minInd = i;
        		}
        	}
        	swap(array, left, minInd);
        }
        System.out.println(Arrays.toString(array));

        - Сортировка вставками (Insertion Sort)
        int[] array = {10, 2, 10, 3, 1, 2, 5};
        System.out.println(Arrays.toString(array));
        for (int left = 0; left < array.length; left++) {
        	// Вытаскиваем значение элемента
        	int value = array[left];
        	// Перемещаемся по элементам, которые перед вытащенным элементом
        	int i = left - 1;
        	for (; i >= 0; i--) {
        		// Если вытащили значение меньшее — передвигаем больший элемент дальше
        		if (value < array[i]) {
        			array[i + 1] = array[i];
        		} else {
        			// Если вытащенный элемент больше — останавливаемся
        			break;
        		}
        	}
        	// В освободившееся место вставляем вытащенное значение
        	array[i + 1] = value;
        }
        System.out.println(Arrays.toString(array));

        - Сортировка Шелла
        nt[] array = {10, 2, 10, 3, 1, 2, 5};
        System.out.println(Arrays.toString(array));
        // Высчитываем промежуток между проверяемыми элементами
        int gap = array.length / 2;
        // Пока разница между элементами есть
        while (gap >= 1) {
            for (int right = 0; right < array.length; right++) {
                // Смещаем правый указатель, пока не сможем найти такой, что
                // между ним и элементом до него не будет нужного промежутка
               for (int c = right - gap; c >= 0; c -= gap) {
                   if (array[c] > array[c + gap]) {
                       swap(array, c, c + gap);
                   }
                }
            }
            // Пересчитываем разрыв
            gap = gap / 2;
        }
        System.out.println(Arrays.toString(array));

        - Быстрая сортировка (Quick Sort)
        public static void quickSort(int[] source, int leftBorder, int rightBorder) {
                int leftMarker = leftBorder;
                int rightMarker = rightBorder;
                int pivot = source[(leftMarker + rightMarker) / 2];
                do {
                    // Двигаем левый маркер слева направо пока элемент меньше, чем pivot
                    while (source[leftMarker] < pivot) {
                        leftMarker++;
                    }
                    // Двигаем правый маркер, пока элемент больше, чем pivot
                    while (source[rightMarker] > pivot) {
                        rightMarker--;
                    }
                    // Проверим, не нужно обменять местами элементы, на которые указывают маркеры
                    if (leftMarker <= rightMarker) {
                        // Левый маркер будет меньше правого только если мы должны выполнить swap
                        if (leftMarker < rightMarker) {
                            int tmp = source[leftMarker];
                            source[leftMarker] = source[rightMarker];
                            source[rightMarker] = tmp;
                        }
                        // Сдвигаем маркеры, чтобы получить новые границы
                        leftMarker++;
                        rightMarker--;
                    }
                } while (leftMarker <= rightMarker);

                // Выполняем рекурсивно для частей
                if (leftMarker < rightBorder) {
                    quickSort(source, leftMarker, rightBorder);
                }
                if (leftBorder < rightMarker) {
                    quickSort(source, leftBorder, rightMarker);
                }
        }